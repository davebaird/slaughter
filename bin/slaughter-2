#!/usr/bin/perl -w

=head1 NAME

slaughter-2 - Perl Automation Tool

=cut

=head1 SYNOPSIS

  General Options:

   --dump          Dump details of the local environment, and immediately exit.
   --no-delete     Don't delete the compiled perl post-execution.
   --no-execute    Don't actually execute the downloaded policy.

  File/Policy Fetching:

   --prefix        The prefix for the transport we're using.
   --transport     The transport to use for policy/file-fetching
   --username      The username for the policy-fetch, if appropriate (http-only).
   --password      The password for the policy-fetch, if appropriate (http-only).
   --transport-args Any arguments to pass to the transport (used for rsync/hg/git).

  Help Options:

   --help        Show the help information for this script.
   --manual      Read the manual for this script.
   --verbose     Show useful debugging information.
   --version     Show the version number of the slaughter client.

=cut


=head1 ABOUT

slaughter is a simple system administration and server automation tool,
which is designed to download policy files from a central server and
execute them locally.

The remote files which are downloaded are actually perl scripts which
are executed with the help of a simple wrapper module - this module
provides several new language functions (or primitives) which can be
useful to manage systems.

=cut


=head1 TRANSPORTS

When this tool is invoked it will attempt to fetch a file called
"policies/default.policy".  This policy may include others, which
are fetched in turn and inserted.

The policies, and any associated files, may be fetched via one of
several mechanisms:

=over 8

=item git

=item http

=item mercurial

=item rsync

=back

The simplest mechanism is HTTP, which can be configured by specifying the
URL of the server from which to download the files, and the transport of
'http'.

Given the configuration:

=for example begin

   --transport=http --prefix=http://server.example.org/slaughter/

=for example end

The client will download the file:

=for example begin

   http://server.example.org/slaughter/policies/default.policy

=for example end

The path "/policies/" is automatically appended to the first fetch,
and to all subsequent policies.  Similarly all files will be assumed
to be beneath the common root of:

=for example begin

   http://server.example.org/slaughter/files/

=for example end

There are examples of other transports, including server-setup, in the
included file TRANSPORTS.

=cut


=head1 PRIMITIVES

There are several primitives available to your code which are actually
implemented in the Slaughter module.

These primitives are more fully described online:

=for example begin

  http://www.steve.org.uk/Software/slaughter/primitives.html

=for example end

=cut


=head1 DEBUGGING

The simplest way to debug a potential problem is to execute slaughter
with both the B<--no-delete> and B<--verbose> options.  This will ensure that
once the policy/policies are downloaded and compiled they will be kept.

The result should be that you'll be shown the name of a file - this file
may be executed interactively to see what is going on.

You may also invoke slaughter with the B<--dump> flag which will cause
it to display the environmental details it has discovered, and which will
be compiled into the policy prior to execution.

=cut


=head1 CONFIGURATION

Most of the configuration of this tool may be carried out via the
command line, however some options may be more naturally supplied
in the system-wide configuration file.

For Unix platforms the globalc configuration file is located at
B</etc/slaughter/slaughter.conf>, and it may be found at B<C:/slaughter.conf>
for Microsoft Windows systems.

A fully-featured file might look something like this:

=for example begin

  #
  #  Comments start with "#"
  #

  #
  #  Be quiet
  ##
  verbose = 0

  #
  # Fetch the default policy from: http://example.com/slaughter/policies/default.policy
  #
  # NOTE: "policies/default.policy" is automatically appended.
  ##
  transport = http
  prefix    = http://example.com/slaughter/

=for example end


=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

=cut


=head1 LICENSE

Copyright (c) 2010-2012 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut


use strict;
use warnings;

use English;
use File::Temp qw/ tempfile tempdir /;
use File::Path qw/ mkpath /;
use Getopt::Long;
use LWP::UserAgent;
use Pod::Usage;



#
# The version of our release.
#
my $VERSION = '__UNRELEASED__';


#
#  Setup default options - include meta-data about the current host.
#
my %CONFIG = defaultOptions();


#
#  Parse configuration file.
#
parseConfigurationFile();


#
#  Parse command line, this takes precedence over the configuration file.
#
parseCommandLine();


#
#  Create a temporary directory, some transports need such a thing.
#
createTransportDir();


#
#  Ensure we're root, and ensure that we have the options setup that we need.
#
testEnvironment();

#
#  Attempt to load the transport the user has specified.
#
my $module = "Slaughter::Transport::$CONFIG{'transport'}";
my $object = $module->new(%CONFIG);

#
# Test that the dependencies for the transport module are present.
#
if ( !$object->isAvailable() )
{
    print
      "The transport module you've chosen - $module - doesn't seem to be available:\n";

    print $object->error() . "\n";
    exit(0);
}

#
#  Now fetch the policies, expanding and recursing, where appropriate.
#
my $policy = $object->fetchPolicies();


#
#  Write it out to disk, with the appropriate wrapper, such that it
#  becomes executable as valid perl.
#
my $file = writeoutPolicy($policy);
$CONFIG{ 'verbose' } && print "Policy written to $file\n";

#
##
###
### TODO : Further work.
###
##
#
exit;


#
#  Run the script locally, unless we're told not to.
#
if ( $CONFIG{ 'noexecute' } )
{
    $CONFIG{ 'verbose' } &&
      print "Not launching script due to --no-execute\n";
}
else
{
    $CONFIG{ 'verbose' } &&
      print "Script starting : " . scalar localtime() . "\n";

    my $cmd = $file;

    #
    #  Execute the compiled code explicitly via the Perl intepreter
    # this is redundent for operating systems that honour the shebang
    # line, but useful for Microsoft Windows.
    #
    my $return = system( "perl " . $cmd );

    #
    #  Show the result?
    #
    $CONFIG{ 'verbose' } &&
      print "Script completed: (return = $return) " . scalar localtime() . "\n";

}



#
#  Cleanup.
#
unlink($file) unless ( $CONFIG{ 'nodelete' } );


#
#  We're all done
#
exit;




=begin doc

Configure the default options, and return these as a hash.

As much as can be determined on "all systems" is defined here, the rest comes
from the "MetaInformation" method of a module loaded dynamically from the
Slaughter::Info namespace.

=end doc

=cut

sub defaultOptions
{
    my %defs = ( version       => 0,
                 verbose       => 0,
                 transportargs => '',
                 nodelete      => 0,
                 noexecute     => 0,
               );


    #
    # Platform/OS (linux or MSWin32)
    #
    $defs{ 'os' } = $^O;

    #
    #  Fully Qualified hostname
    #
    #  1.  If we can find /etc/hostname, then use that.
    #
    if ( -e "/etc/hostname" )
    {
        open( my $file, "<", "/etc/hostname" ) or
          die "Failed to read /etc/hostname - $!";
        $defs{ 'fqdn' } = <$file>;
        chomp( $defs{ 'fqdn' } );
        close($file);
    }
    else
    {

        #
        #  Call "hostname".
        #
        $defs{ 'fqdn' } = `hostname`;
        chomp( $defs{ 'fqdn' } );

        #
        # If it is unqualified retry with --fqdn.
        #
        if ( $defs{ 'fqdn' } !~ /\./ )
        {
            $defs{ 'fqdn' } = `hostname --fqdn`;
            chomp( $defs{ 'fqdn' } );
        }
    }


    #
    #  Get the hostname and domain name as seperate strings.
    #
    if ( $defs{ 'fqdn' } =~ /^([^.]+)\.(.*)$/ )
    {
        $defs{ 'hostname' } = $1;
        $defs{ 'domain' }   = $2;
    }
    else
    {

        #
        #  Better than nothing, right?
        #
        $defs{ 'hostname' } = $defs{ 'fqdn' };
        $defs{ 'domain' }   = $defs{ 'fqdn' };
    }


    #
    #  Is this a xen host, or guest?
    #
    $defs{ 'xen' } = 1 if -d "/proc/xen/capabilities";

    #
    #  KVM / Qemu?
    #
    if ( open( my $cpu, "<", "/proc/cpuinfo" ) )
    {
        foreach my $line (<$cpu>)
        {
            chomp($line);
            $defs{ 'kvm' } = 1 if ( $line =~ /model/ && $line =~ /qemu/i );
        }
        close($cpu);
    }


    #
    #  Softare RAID?
    #
    if ( ( -e "/proc/mdstat" ) &&
         ( -x "/sbin/mdadm" ) )
    {
        if ( open( my $mdstat, "<", "/proc/mdstat" ) )
        {
            foreach my $line (<$mdstat>)
            {
                if ( ( $line =~ /^md([0-9]+)/ ) &&
                     ( $line =~ /active/i ) )
                {
                    $defs{ 'softwareraid' } = 1;
                    $defs{ 'raid' }         = "software";
                }
            }
            close($mdstat);
        }
    }



    #
    #  Attempt to load a module which will add to the meta-information
    # we've already collected about this host.
    #
    #  Mostly this will be architecture-specific information and things
    # like the IP addresses.
    #
    my $generic  = "use Slaughter::Info::generic";
    my $specific = "use Slaughter::Info::$^O";

    ## no critic (Eval)
    eval($specific);
    ## use critic

    # if there were errors then we'll use the generic
    # handler
    if ($@)
    {
        print $@;
        eval($generic);
    }

    #
    #  Now we're going to populate the information via our module...
    #
    MetaInformation( \%defs );

    #
    #  Return the (hopefully updated) meta-information
    #
    return (%defs);
}




=begin doc

Parse the configuration file.

=end doc

=cut

sub parseConfigurationFile
{
    my $config = undef;

    #
    #  Try each of the configuration files in turn.
    #
    foreach my $conf (qw! /etc/slaughter/slaughter.conf C:/slaughter.conf !)
    {
        $config = $conf if ( -e $conf );
    }

    #
    #  Failed to find a configuration file.
    #
    return if ( !defined($config) );

    #
    #  Show what we used.
    #
    $CONFIG{ 'verbose' } && print "Reading configuration file: $config\n";

    #
    #  Failed to open?  Return
    #
    open my $handle, "<", $config or
      return;

    while ( my $line = <$handle> )
    {
        chomp $line;
        if ( $line =~ s/\\$// )
        {
            $line .= <$handle>;
            redo unless eof($handle);
        }

        # Skip lines beginning with comments
        next if ( $line =~ /^([ \t]*)\#/ );

        # Skip blank lines
        next if ( length($line) < 1 );

        # Strip trailing comments.
        if ( $line =~ /(.*)\#(.*)/ )
        {
            $line = $1;
        }

        # Find variable settings
        if ( $line =~ /([^=]+)=([^\n]+)/ )
        {
            my $key = $1;
            my $val = $2;

            # Strip leading and trailing whitespace.
            $key =~ s/^\s+//;
            $key =~ s/\s+$//;
            $val =~ s/^\s+//;
            $val =~ s/\s+$//;

            # Store value.
            $CONFIG{ $key } = $val;
        }
    }
    close($handle);
}


=begin doc

Parse the command line for options.

=end doc

=cut

sub parseCommandLine
{
    my $SHOW_HELP    = 0;
    my $SHOW_MANUAL  = 0;
    my $SHOW_VERSION = 0;

    if (
        !GetOptions(

            # Help options
            "help",    \$SHOW_HELP,
            "manual",  \$SHOW_MANUAL,
            "version", \$SHOW_VERSION,

            # For fetching policies.
            "transport=s",    \$CONFIG{ 'transport' },
            "prefix=s",       \$CONFIG{ 'prefix' },
            "transport-args", \$CONFIG{ 'transportargs' },

            "username=s", \$CONFIG{ 'username' },
            "password=s", \$CONFIG{ 'password' },

            # Flags
            "dump",       \$CONFIG{ 'dump' },
            "no-delete",  \$CONFIG{ 'nodelete' },
            "no-execute", \$CONFIG{ 'noexecute' },
            "verbose",    \$CONFIG{ 'verbose' },
        ) )
    {
        exit 1;
    }

    pod2usage(1) if $SHOW_HELP;
    pod2usage( -verbose => 2 ) if $SHOW_MANUAL;


    #
    #  Showing the version number only?
    #
    if ($SHOW_VERSION)
    {
        print $VERSION . "\n";
        exit;
    }

    #
    #  If we're dumping, do that.
    #
    if ( $CONFIG{ 'dump' } )
    {
        use Data::Dumper;
        print Dumper( \%CONFIG );
        exit;
    }

}



=begin doc

Create a temporary directory for holding files, some transports need this.

Note this directory will be removed when this process terminates unless
it was invoked with --no-delete.

=end doc

=cut

sub createTransportDir
{

    #
    #  Temporary directory for transports to use
    #
    $CONFIG{ 'transportDir' } = tempdir( CLEANUP => !$CONFIG{ 'nodelete' } );

    #  The temporary directory should not be world-readable
    chmod 0700, $CONFIG{ 'transportDir' };
}



=begin doc

Test the environment.

=end doc

=cut

sub testEnvironment
{
    if ( $UID != 0 )
    {
        print <<EOF;
You must launch this command as root.
EOF
        exit 1;
    }


    #
    #  Attempt to load the transport module the user has specified
    #
    my $transport = "use Slaughter::Transport::$CONFIG{'transport'}";

    ## no critic (Eval)
    eval($transport);
    ## use critic

    if ($@)
    {
        print "The transport method you've chosen doesn't seem to exist.\n";
        print $@;

        exit(0);
    }
}



=begin doc

Write out specified policy content into a form which can be executed,
and return the name of the file to which it was written.

=end doc

=cut

sub writeoutPolicy
{
    my ($txt) = (@_);

    my ( undef, $name ) = File::Temp::tempfile();

    open my $handle, ">", $name or
      die "Failed to write to file : $!";

    print $handle <<EOF;
#!/usr/bin/perl
use strict;
use warnings;

use Slaughter;


# template variables.
EOF

    my $line = "my \%template = (";

    foreach my $key ( keys %CONFIG )
    {
        my $val = $CONFIG{ $key };

        if ( defined($val) )
        {
            print $handle "our \$$key = '$val';\n";
            $line .= "\n\t$key => '$val',";
        }
        else
        {
            print $handle "our \$$key = undef;\n";
            $line .= "\n\t$key => undef,";
        }

    }

    $line =~ s/, $//g;
    $line .= "\t);\n";
    print $handle "\n# template hash\n";
    print $handle $line . "\n";
    print $handle "#========\n\n";

    print $handle <<EOF;

#
# TRANSPORT SETUP
#
use Slaughter::Transport::$CONFIG{'transport'};
our \$TRANSPORT = Slaughter::Transport::$CONFIG{'transport'}->new( \%template );

EOF

    print $handle $txt;
    close($handle);

    if ( $^O ne "MSWin32" )
    {
        chmod( 0700, $name );
    }

    return ($name);

}
