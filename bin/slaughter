#!/usr/bin/perl -w

=head1 NAME

slaughter - Perl Automation Tool

=cut

=head1 SYNOPSIS


  General Options:

   --keep          Don't delete the compiled perl post-execution.
   --policy        Specify the policy file to load; default is "default.policy".
   --server        Specify the file server to load policies from.

  Help Options:

   --help        Show the help information for this script.
   --manual      Read the manual for this script.
   --verbose     Show useful debugging information.

=cut


=head1 ABOUT

slaugher is a simple system administration and server automation tool,
which is designed to download policy files from a remote server via
HTTP.

The remote files which are downloaded are actually perl scripts which
are executed with the help of a simple wrapper module - this module
provides several new language functions (or primitives) which can be
useful to manage systems.

When this tool is invoked, with an appropriate server configured, it
will attempt to download and execute the contents of:

=for example begin

   http://server/slaughter/default.policy

=for example end

This simple policy file may in turn include other policy files, or it
might contain perl code to execute.

=cut


=head1 PRIMITIVES

There are several primitives available to your code which are actually
implemented in the Slaughter module.

These primitives are more fully described online:

=for example begin

  http://www.steve.org.uk/Software/slaughter/primitives.html

=for example end

=cut


=head1 LOGGING

The output of any given run will be appended to the file
/var/log/slaughter.log


=cut


=head1 DEBUGGING

The simplest way to debug a potential problem is to execute slaughter
with both the B<--keep> and B<--verbose> options.  This will ensure that
once the policy/policies are downloaded and compiled they will be kept.

The result should be that you'll be shown the name of a file - this file
may be executed interactively to see what is going on.

=cut


=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

=cut

=head1 LICENSE

Copyright (c) 2010 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut



use strict;
use warnings;


use English;
use File::Temp;
use Getopt::Long;
use LWP::UserAgent;
use Pod::Usage;



#
#  Find our hostname, IP address, etc.
#
my %SYSTEM = findSystemDetails();


#
#  Configuration variables.
#
my %CONFIG;


#
#  Parse our configuration file.
#
parseConfigurationFile();


#
#  Parse any command line options.
#
parseCommandLine();


#
#  Ensure we have a server.
#
validateEnvironment();


#
#  Find the policy to fetch.  This will be "default.policy" unless
# a different one is specified.
#
my $policy = "http://$CONFIG{'server'}/slaughter/policies/";

if ( $CONFIG{ 'policy' } )
{
    $policy .= $CONFIG{ 'policy' };
}
else
{
    $policy .= "default.policy";
}



#
#  Fetch the contents of the actual policy, recursively handling
# include files.
#
my $contents = fetchPolicy($policy);


#
#  Write it out
#
my $file = writeoutPolicy($contents);


#
#  Call the policy
#
system("$file  2>&1 >> /var/log/slaughter.log");


#
#  All done
#
if ( $CONFIG{ 'keep' } )
{
    print "File left at: $file\n";
}
else
{
    unlink($file);
}


exit 0;




=begin doc

Find the system details.

=end doc

=cut

sub findSystemDetails
{
    my %info;

    #
    #  Fully Qualified hostname
    #
    $info{ 'fqdn' } = `hostname`;
    chomp( $info{ 'fqdn' } );

    #
    #  Get the hostname and domain name as seperate strings.
    #
    if ( $info{ 'fqdn' } =~ /^([^.]+)\.(.*)$/ )
    {
        $info{ 'hostname' } = $1;
        $info{ 'domain' }   = $2;
    }
    else
    {
        #
        #  Better than nothing, right?
        #
        $info{'hostname'} = $info{'fqdn'};
        $info{'domain'} = $info{'fqdn'};
    }


    #
    #  Kernel
    #
    $info{ 'kernel' } = `uname -r`;
    chomp( $info{ 'kernel' } );

    #
    #  Are we i386/amd64?
    #
    $info{ 'arch' } = "i386";
    $info{ 'bits' } = 32;

    my $type = `file /bin/ls`;
    if ( $type =~ /64-bit/i )
    {
        $info{ 'arch' } = "amd64";
        $info{ 'bits' } = 64;
    }

    #
    #  Xen?
    #
    $info{ 'xen' } = 1 if -d "/proc/xen/capabilities";

    #
    #  KVM / Qemu?
    #
    if ( open( my $cpu, "<", "/proc/cpuinfo" ) )
    {
        foreach my $line (<$cpu>)
        {
            chomp($line);

            $info{ 'kvm' } = 1 if ( $line =~ /model/ && $line =~ /qemu/i );
        }
        close($cpu);
    }


    #
    #  Softare RAID?
    #
    if ( ( -e "/proc/mdstat" ) &&
         ( -x "/sbin/mdadm" ) )
    {
        if ( open( my $mdstat, "<", "/proc/mdstat" ) )
        {
            foreach my $line (<$mdstat>)
            {
                if ( ( $line =~ /^md([0-9]+)/ ) &&
                     ( $line =~ /active/i ) )
                {
                    $info{ 'softwareraid' } = 1;
                    $info{ 'raid' }         = "software";
                }
            }
            close($mdstat);
        }
    }


    #
    #  TODO: IP address
    #

    #
    #  TODO: 3Ware RAID?
    #

    #
    #  TODO: HP RAID?
    #

    return %info;
}




=begin doc

Some minimal command line parsing.

=end doc

=cut

sub parseCommandLine
{
    my $HELP   = 0;
    my $MANUAL = 0;

    if (
         !GetOptions(
                     # Help options
                     "help",    \$HELP,
                     "manual",  \$MANUAL,

                     # General options
                     "server=s", \$CONFIG{ 'server' },
                     "policy=s", \$CONFIG{ 'policy' },
                     "keep",     \$CONFIG{ 'keep' },
                     "verbose",  \$CONFIG{ 'verbose' },
                    ) )
    {
        exit 1;
    }

    if ( $CONFIG{ 'verbose' } )
    {
        $SYSTEM{ 'verbose' } = 1;
    }
    else
    {
        $SYSTEM{ 'verbose' } = 0;
    }


    pod2usage(1) if $HELP;
    pod2usage( -verbose => 2 ) if $MANUAL;
}



=begin doc

Parse the configuration file.

=end doc

=cut

sub parseConfigurationFile
{
    return unless ( -e "/etc/slaughter/slaughter.conf" );

    open my $handle, "<", "/etc/slaughter/slaughter.conf" or
      return;

    while ( my $line = <$handle> )
    {
        chomp $line;
        if ( $line =~ s/\\$// )
        {
            $line .= <$handle>;
            redo unless eof($handle);
        }

        # Skip lines beginning with comments
        next if ( $line =~ /^([ \t]*)\#/ );

        # Skip blank lines
        next if ( length($line) < 1 );

        # Strip trailing comments.
        if ( $line =~ /(.*)\#(.*)/ )
        {
            $line = $1;
        }

        # Find variable settings
        if ( $line =~ /([^=]+)=([^\n]+)/ )
        {
            my $key = $1;
            my $val = $2;

            # Strip leading and trailing whitespace.
            $key =~ s/^\s+//;
            $key =~ s/\s+$//;
            $val =~ s/^\s+//;
            $val =~ s/\s+$//;

            # Store value.
            $CONFIG{ $key } = $val;
        }
    }
    close($handle);
}




=begin doc

Ensure that we're launched by root (such that we have permission to
do admin things) and that we have a server defined.

=end doc

=cut

sub validateEnvironment
{
    if ( !$CONFIG{ 'server' } )
    {
        print <<EOF;
You need to specify the server which this node will fetch the policies
from.  You can either do this by running:

$0 slaughter --server=foo.example.org

Or by:

echo "server = foo.example.org" >> /etc/slaughter/slaughter.conf
EOF
        exit 1;
    }

    if ( $UID != 0 )
    {
        print <<EOF;
You must launch this command as root.
EOF
        exit 1;
    }
}




=begin doc

Fetch the contents of a remote URL.

Recursively handle "FetchPolicy xxx ; " statements, and if a file isn't
found then return "" - so that we don't stop execution.

=end doc

=cut


sub fetchPolicy
{
    my ($url) = (@_);

    $CONFIG{ 'verbose' } && print "Fetching $url\n";

    #
    #  Save the server
    #
    if ( !$SYSTEM{ 'server' } )
    {
        if ( $url =~ /:\/\/([^\/]+)\// )
        {
            $SYSTEM{ 'server' } = $1;
        }
    }


    my $ua = LWP::UserAgent->new();
    $ua->env_proxy();


    my $ret = "";

    $ret = <<EOF;

#
# $url
#
EOF

    #
    #  If we have a template handle it.
    #
    if ( $url =~ /(.*)\$([^.]+)\.(.*)/ )
    {
        $url = $1 . $SYSTEM{ $2 } . "." . $3;
        print "\tNew URL: $url\n";
    }

    my $response = $ua->get($url);
    if ( $response->is_success() )
    {
        my $txt = $response->decoded_content();

        foreach my $line ( split( /[\r\n]/, $txt ) )
        {
            if ( $line =~ /FetchPolicy([ \t]+)(.*)[ \t]*\;/i )
            {
                my $inc = $2;

                ##
                ## Fully qualified URL?
                ##
                if ( $inc =~ /:\/\// )
                {
                    $ret .= fetchPolicy($inc);
                }
                else
                {

                    #
                    #  Try to resolve the path.
                    #
                    if ( $url =~ /^(.*)\/([^\/]+)$/ )
                    {
                        $inc = $1 . "/" . $inc;

                        $ret .= fetchPolicy($inc);
                    }
                }
            }
            else
            {
                $ret .= $line;
            }

            $ret .= "\n";
        }
    }
    else
    {
        print "\tFailed to fetch: $url\n";
        print "\t" . $response->status_line() . "\n";
        return "";
    }

    return ($ret);
}


=begin doc

Write out specified policy content into a form which can be executed,
and return the name of the file to which it was written.

=end doc

=cut

sub writeoutPolicy
{
    my ($txt) = (@_);

    my ( undef, $name ) = File::Temp::tempfile();

    open my $handle, ">", $name or
      die "Failed to write to file : $!";

    print $handle <<EOF;
#!/usr/bin/perl
use strict;
use warnings;

use Slaughter;

# definitions set with Define
our %DEFINES;


# template variables.
EOF

    my $line = "my \%template = (";

    foreach my $key ( keys %SYSTEM )
    {
        my $val = $SYSTEM{ $key };

        print $handle "our \$$key = '$val';\n";

        $line .= "\n\t$key => '$val',";
    }

    $line =~ s/, $//g;
    $line .= "\t);\n";
    print $handle "\n# template hash\n";
    print $handle $line . "\n";
    print $handle "#========\n\n";

    print $handle $txt;
    close($handle);

    system( "chmod", "755", $name );

    return ($name);

}
