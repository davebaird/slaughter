#!/usr/bin/perl -w

=head1 NAME

slaughter - Perl Automation Tool

=cut

=head1 SYNOPSIS


  General Options:

   --dump        Dump details of the local environment.
   --email       Output the logfile via email to the specified address.
   --keep        Don't delete the compiled perl post-execution.
   --no-execute  Don't actually execute the downloaded policy.
   --no-log      Don't redirect run output to a log file.
                 (Can't be used with --email)
   --policy      Specify the policy file to load; default is "default.policy".
   --prefix      The web-prefix beneath which /files and /policies live.
   --protocol    The protocol to use "http" vs "https".
   --server      Specify the file server to fetch policies from.

  Help Options:

   --help        Show the help information for this script.
   --manual      Read the manual for this script.
   --verbose     Show useful debugging information.
   --version     Show the version number of the slaughter client.

=cut


=head1 ABOUT

slaugher is a simple system administration and server automation tool,
which is designed to download policy files from a remote server via
HTTP.

The remote files which are downloaded are actually perl scripts which
are executed with the help of a simple wrapper module - this module
provides several new language functions (or primitives) which can be
useful to manage systems.

When this tool is invoked, with an appropriate server configured, it
will attempt to download and execute the contents of:

=for example begin

   http://server.example.org/slaughter/policies/default.policy

=for example end

This simple policy file may in turn include other policy files, or it
might contain perl code to execute.

The path to the policies will default to /slaughter/policies/, and
file-fetches will be pulled from /slaughter/files/ - you may change
the /slaughter/ prefix with the B<--prefix> command-line argument.

=cut


=head1 PRIMITIVES

There are several primitives available to your code which are actually
implemented in the Slaughter module.

These primitives are more fully described online:

=for example begin

  http://www.steve.org.uk/Software/slaughter/primitives.html

=for example end

=cut


=head1 LOGGING

The output of any given run will saved to a file beneath the directory
B</var/log/slaughter>.  (This directory will be created if it is missing.)

=cut


=head1 DEBUGGING

The simplest way to debug a potential problem is to execute slaughter
with both the B<--keep> and B<--verbose> options.  This will ensure that
once the policy/policies are downloaded and compiled they will be kept.

The result should be that you'll be shown the name of a file - this file
may be executed interactively to see what is going on.

You may also invoke slaughter with the B<--dump> flag which will cause
it to display the environmental details it has discovered, and which will
be compiled into the policy prior to execution.

=cut

=head1 CONFIGURATION

Most of the configuration of this tool may be carried out via the
command line, however some options may be more naturally supplied
in the system-wide configuration file.

For Unix platforms the globalc configuration file is located at
B</etc/slaughter/slaughter.conf>, and it may be found at B<C:/slaughter.conf>
for Microsoft Windows systems.

A fully-featured file might look something like this:

=for example begin

  #
  #  Comments start with "#"
  #

  #  Email address to send non-empty results to
  ##
  email = sysadmin@example.com

  #  Sender address for the mails
  ##
  sender = root@example.com

  #  Sendmail path/args
  ##
  sendmail = /usr/lib/sendmail -t

  #  Be quiet
  ##
  verbose = 0

  # Server details: http://example.com/slaughter/policies/default.policy
  ##
  protocol = http://
  server   = example.com
  prefix   = /slaughter/

=for example end

=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

=cut

=head1 LICENSE

Copyright (c) 2010-2011 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut


use strict;
use warnings;

use English;
use File::Temp qw/ tempfile /;
use File::Path qw/ mkpath /;
use Getopt::Long;
use LWP::UserAgent;
use Pod::Usage;



#
# The version of our release.
#
my $VERSION = '1.4';


#
#  Setup default options.
#
my %CONFIG = defaultOptions();




#
#  Parse configuration file.
#
parseConfigurationFile();


#
#  Parse command line.
#
parseCommandLine();


#
#  Ensure we're root, and ensure that we have the options setup that we need.
#
testEnvironment();


#
#  Fetch the remote policy via http/https
#
my $policy = fetchRemotePolicy(
             $CONFIG{ 'protocol' } . $CONFIG{ 'server' } . $CONFIG{ 'prefix' } .
               "policies/" . $CONFIG{ 'policy' } );


#
#  Write it out to disk, with the appropriate wrapper stuff so that
# it gets setup.
#
my $file = writeoutPolicy($policy);
$CONFIG{ 'verbose' } && print "Policy written to $file\n";


#
#  Test at this point that we have the modules required for this particular
# operating system.
#
#  TODO
#

#
#  Find the logfile to write our run to.
#
my $logfile = getLogfile();

#
#  Run the script locally
#
if ( $CONFIG{ 'noexecute' } )
{
    $CONFIG{ 'verbose' } &&
      print "Not launching script due to --no-execute\n";
}
else
{
    $CONFIG{ 'verbose' } &&
      print "Script starting : " . scalar localtime() . "\n";

    my $cmd = $file;
    unless ( $CONFIG{ 'nolog' } )
    {
        $cmd .= " 2>&1 >> $logfile";
    }

    my $return = 0;
    if ( $^O eq "MSWin32" )
    {
        $return = system( "perl " . $cmd );
    }
    else
    {
        $return = system($cmd );
    }

    $CONFIG{ 'verbose' } &&
      print "Script completed: (return = $return) " . scalar localtime() . "\n";

}



#
#  Submit the logfile via email if we should.
#
if ( $CONFIG{ 'email' } )
{
    emailLogfile( $CONFIG{ 'email' }, $logfile );
}


#
#  Cleanup.
#
unlink($file) unless ( $CONFIG{ 'keep' } );


#
#  We're all done
#
exit;




=begin doc

Configure the default options, and return these as a hash.

=end doc

=cut

sub defaultOptions
{
    my %defs = (
        version  => 0,
        verbose  => 0,
        prefix   => "/slaughter/",
        policy   => "default.policy",
        protocol => "http://",

               );

    #
    #  Find the system information.
    #
    if ( $^O eq "MSWin32" )
    {
        findSystemDetailsWin32( \%defs );
    }
    else
    {
        findSystemDetails( \%defs );
    }

    return (%defs);
}


=begin doc

Here we find details about the system which will be included in the
generated file script.

=end doc

=cut

sub findSystemDetails
{
    my ($ref) = (@_);

    #
    #  Fully Qualified hostname
    #
    #  1.  If we can find /etc/hostname, then use that.
    #
    if ( -e "/etc/hostname" )
    {
        open( my $file, "<", "/etc/hostname" ) or
          die "Failed to read /etc/hostname - $!";
        $ref->{ 'fqdn' } = <$file>;
        chomp( $ref->{ 'fqdn' } );
        close($file);
    }
    else
    {

        #
        #  Ok /etc/hostname is missing.
        #
        #  Call "hostname".
        #
        $ref->{ 'fqdn' } = `hostname`;
        chomp( $ref->{ 'fqdn' } );

        #
        # If it is unqualified retry with --fqdn.
        #
        if ( $ref->{ 'fqdn' } !~ /\./ )
        {
            $ref->{ 'fqdn' } = `hostname --fqdn`;
            chomp( $ref->{ 'fqdn' } );
        }
    }

    #
    #  Get the hostname and domain name as seperate strings.
    #
    if ( $ref->{ 'fqdn' } =~ /^([^.]+)\.(.*)$/ )
    {
        $ref->{ 'hostname' } = $1;
        $ref->{ 'domain' }   = $2;
    }
    else
    {

        #
        #  Better than nothing, right?
        #
        $ref->{ 'hostname' } = $ref->{ 'fqdn' };
        $ref->{ 'domain' }   = $ref->{ 'fqdn' };
    }


    #
    #  Kernel version.
    #
    $ref->{ 'kernel' } = `uname -r`;
    chomp( $ref->{ 'kernel' } );

    #
    #  Are we i386/amd64?
    #
    my $type = `file /bin/ls`;
    if ( $type =~ /64-bit/i )
    {
        $ref->{ 'arch' } = "amd64";
        $ref->{ 'bits' } = 64;
    }
    else
    {
        $ref->{ 'arch' } = "i386";
        $ref->{ 'bits' } = 32;
    }

    #
    # Platform/OS (linux or MSWin32)
    #
    $ref->{ 'os' } = $^O;

    #
    #  Xen?
    #
    $ref->{ 'xen' } = 1 if -d "/proc/xen/capabilities";

    #
    #  KVM / Qemu?
    #
    if ( open( my $cpu, "<", "/proc/cpuinfo" ) )
    {
        foreach my $line (<$cpu>)
        {
            chomp($line);

            $ref->{ 'kvm' } = 1 if ( $line =~ /model/ && $line =~ /qemu/i );
        }
        close($cpu);
    }


    #
    #  Softare RAID?
    #
    if ( ( -e "/proc/mdstat" ) &&
         ( -x "/sbin/mdadm" ) )
    {
        if ( open( my $mdstat, "<", "/proc/mdstat" ) )
        {
            foreach my $line (<$mdstat>)
            {
                if ( ( $line =~ /^md([0-9]+)/ ) &&
                     ( $line =~ /active/i ) )
                {
                    $ref->{ 'softwareraid' } = 1;
                    $ref->{ 'raid' }         = "software";
                }
            }
            close($mdstat);
        }
    }


    #
    #  IP address(es).
    #
    my $ip = undef;

    $ip = "/sbin/ip" if ( -x "/sbin/ip" );
    $ip = "/bin/ip"  if ( -x "/bin/ip" );

    if ( defined($ip) )
    {
        my $count = 1;

        foreach my $line (
                   split( /[\r\n]/, `$ip -o -f inet  addr show scope global` ) )
        {
            next if ( !defined($line) || !length($line) );
            chomp($line);

            #
            #  This matches something like:
            #
            #  2: eth0    inet 192.168.1.9/24 brd 192.168.1.255 scope global eth0
            #
            #
            if ( $line =~ /^([0-9]+):[ \t]+([^ ]+)[ \t]*inet[ \t]+([0-9\.]+)/ )
            {
                my $eth = $2;
                my $ip  = $3;

                #
                # Save away the IP address in "ip0", "ip1", "ip2" .. etc.
                #
                $ref->{ "ip" . $count } = $ip;
                $count += 1;
            }
        }

        if ( $count > 0 )
        {
            $ref->{ 'ipcount' } = ( $count - 1 );
        }
    }


    #
    #  Find the name of our release
    #

    my $version = "unknown";
    my $distrib = "unknown";
    my $release = "unknown";
    if ( -x "/usr/bin/lsb_release" )
    {
        foreach
          my $line ( split( /[\r\n]/, `/usr/bin/lsb_release -a 2>/dev/null` ) )
        {
            chomp $line;
            if ( $line =~ /Distributor ID:\s*(.*)/ )
            {
                $distrib = $1;
            }
            if ( $line =~ /Release:\s*(.*)/ )
            {
                $version = $1;
            }
            if ( $line =~ /Codename:\s*(.*)/ )
            {
                $release = $1;
            }
        }
    }
    $ref->{ 'version' }      = $version;
    $ref->{ 'distribution' } = $distrib;
    $ref->{ 'release' }      = $release;


    #
    #  TODO: 3Ware RAID?
    #

    #
    #  TODO: HP RAID?
    #

}



=begin doc

Here we find details about the system which will be included in the
generated file script.  This is largely a duplicate of the previous
version but includes some Microsoft Windows-specific code.

TODO: We should merge this in the future.

=end doc

=cut

sub findSystemDetailsWin32
{
    my ($ref) = (@_);

    #
    #  Fully Qualified hostname
    #
    #
    #  Call "hostname".
    #
    $ref->{ 'fqdn' } = `hostname`;
    chomp( $ref->{ 'fqdn' } );

    #
    #  Get the hostname and domain name as seperate strings.
    #
    if ( $ref->{ 'fqdn' } =~ /^([^.]+)\.(.*)$/ )
    {
        $ref->{ 'hostname' } = $1;
        $ref->{ 'domain' }   = $2;
    }
    else
    {

        #
        #  Better than nothing, right?
        #
        $ref->{ 'hostname' } = $ref->{ 'fqdn' };
        $ref->{ 'domain' }   = $ref->{ 'fqdn' };
    }


    #
    #  Kernel version.
    #
    $ref->{ 'kernel' } = $ENV{ 'OS' };
    chomp( $ref->{ 'kernel' } );

    #
    #  Are we i386/amd64?
    #
    my $type = $ENV{ 'PROCESSOR_ARCHITECTURE' };
    if ( $type =~ /x86/i )
    {
        $ref->{ 'arch' } = "i386";
        $ref->{ 'bits' } = 32;
    }
    else
    {
        $ref->{ 'arch' } = "amd64";
        $ref->{ 'bits' } = 64;
    }

    #
    # Platform/OS (linux or MSWin32)
    #
    $ref->{ 'os' } = $^O;

    #
    #  Xen?
    #
    $ref->{ 'xen' } = 1 if -d "/proc/xen/capabilities";

    #
    #  KVM / Qemu?
    #
    if ( open( my $cpu, "<", "/proc/cpuinfo" ) )
    {
        foreach my $line (<$cpu>)
        {
            chomp($line);

            $ref->{ 'kvm' } = 1 if ( $line =~ /model/ && $line =~ /qemu/i );
        }
        close($cpu);
    }


    #
    #  Softare RAID?
    #
    if ( ( -e "/proc/mdstat" ) &&
         ( -x "/sbin/mdadm" ) )
    {
        if ( open( my $mdstat, "<", "/proc/mdstat" ) )
        {
            foreach my $line (<$mdstat>)
            {
                if ( ( $line =~ /^md([0-9]+)/ ) &&
                     ( $line =~ /active/i ) )
                {
                    $ref->{ 'softwareraid' } = 1;
                    $ref->{ 'raid' }         = "software";
                }
            }
            close($mdstat);
        }
    }


    #
    #  IP address(es).
    #
    my $ip = undef;

    $ip = "ipconfig";

    if ( defined($ip) )
    {
        my $count = 1;

        foreach my $line ( split( /[\r\n]/, `$ip` ) )
        {
            next if ( !defined($line) || !length($line) );
            chomp($line);

            #
            #  This matches something like:
            #
            #  IP Address. . . . . . . . . . . . : 10.6.11.138
            #
            #
            if ( $line =~ /IP Address.* : (.*)/ )
            {
                my $ip = $1;

                #
                # Save away the IP address in "ip0", "ip1", "ip2" .. etc.
                #
                $ref->{ "ip" . $count } = $ip;
                $count += 1;
            }
        }

        if ( $count > 0 )
        {
            $ref->{ 'ipcount' } = ( $count - 1 );
        }
    }


    #
    #  Find the name of our release
    #
    my @win_info = Win32::GetOSVersion();
    my $version  = $win_info[0];
    my $distrib  = Win32::GetOSName();

    # work around for historical reasons
    $distrib = 'WinXP' if $distrib =~ /^WinXP/;
    $ref->{ 'version' }      = $version;
    $ref->{ 'distribution' } = $distrib;

    #
    #  TODO: 3Ware RAID?
    #

    #
    #  TODO: HP RAID?
    #

}


=begin doc

Parse the configuration file.

=end doc

=cut

sub parseConfigurationFile
{
    my $config = undef;

    #
    #  Try each of the configuration files in turn.
    #
    foreach my $conf (qw! /etc/slaughter/slaughter.conf C:/slaughter.conf !)
    {
        $config = $conf if ( -e $conf );
    }

    #
    #  Failed to find a configuration file.
    #
    return if ( !defined($config) );

    #
    #  Show what we used.
    #
    $CONFIG{ 'verbose' } && print "Reading configuration file: $config\n";

    #
    #  Failed to open?  Return
    #
    open my $handle, "<", $config or
      return;

    while ( my $line = <$handle> )
    {
        chomp $line;
        if ( $line =~ s/\\$// )
        {
            $line .= <$handle>;
            redo unless eof($handle);
        }

        # Skip lines beginning with comments
        next if ( $line =~ /^([ \t]*)\#/ );

        # Skip blank lines
        next if ( length($line) < 1 );

        # Strip trailing comments.
        if ( $line =~ /(.*)\#(.*)/ )
        {
            $line = $1;
        }

        # Find variable settings
        if ( $line =~ /([^=]+)=([^\n]+)/ )
        {
            my $key = $1;
            my $val = $2;

            # Strip leading and trailing whitespace.
            $key =~ s/^\s+//;
            $key =~ s/\s+$//;
            $val =~ s/^\s+//;
            $val =~ s/\s+$//;

            # Store value.
            $CONFIG{ $key } = $val;
        }
    }
    close($handle);
}


=begin doc

Parse the command line for options.

=end doc

=cut

sub parseCommandLine
{
    my $SHOW_HELP    = 0;
    my $SHOW_MANUAL  = 0;
    my $SHOW_VERSION = 0;

    if (
        !GetOptions(

            # Help options
            "help",    \$SHOW_HELP,
            "manual",  \$SHOW_MANUAL,
            "version", \$SHOW_VERSION,

            # General options
            "email=s",    \$CONFIG{ 'email' },
            "policy=s",   \$CONFIG{ 'policy' },
            "prefix=s",   \$CONFIG{ 'prefix' },
            "protocol=s", \$CONFIG{ 'protocol' },
            "server=s",   \$CONFIG{ 'server' },

            # Flags
            "dump",       \$CONFIG{ 'dump' },
            "keep",       \$CONFIG{ 'keep' },
            "no-execute", \$CONFIG{ 'noexecute' },
            "no-log",     \$CONFIG{ 'nolog' },
            "verbose",    \$CONFIG{ 'verbose' },
        ) )
    {
        exit 1;
    }

    pod2usage(1) if $SHOW_HELP;
    pod2usage( -verbose => 2 ) if $SHOW_MANUAL;


    #
    #  Showing the version number only?
    #
    if ($SHOW_VERSION)
    {
        print $VERSION . "\n";
        exit;
    }

    #
    #  If we're dumping, do that.
    #
    if ( $CONFIG{ 'dump' } )
    {
        use Data::Dumper;
        print Dumper( \%CONFIG );
        exit;
    }

}


=begin doc

Test the environment.

=end doc

=cut

sub testEnvironment
{
    if ( !$CONFIG{ 'server' } )
    {
        print <<EOF;
You need to specify the server which this client will fetch the policies
from.  You can either do this by running:

   slaughter --server=foo.example.org

Or by:

echo "server = foo.example.org" >> /etc/slaughter/slaughter.conf
EOF
        exit 1;
    }

    if ( $UID != 0 )
    {
        print <<EOF;
You must launch this command as root.
EOF
        exit 1;
    }

    if ( $CONFIG{ 'nolog' } && $CONFIG{ 'email' } )
    {
        die "You cannot use --email and --no-log at the same time!\n";
    }

}


=begin doc

Fetch the remote policy via HTTP or HTTPS.

Any line which matches:

FetchPolicy xxxxx;

Will be replaced with the output of that URL.

=end doc

=cut

sub fetchRemotePolicy
{
    my ($url) = (@_);

    $CONFIG{ 'verbose' } && print "Starting Policy: $url\n";

    my $contents = fetchPolicy($url);

    if ( defined $contents )
    {
        my $ret = "";

        foreach my $line ( split( /[\r\n]/, $contents ) )
        {

            # Skip lines beginning with comments
            next if ( $line =~ /^([ \t]*)\#/ );

            # Skip blank lines
            next if ( length($line) < 1 );

            if ( $line =~ /FetchPolicy([ \t]+)(.*)[ \t]*\;/i )
            {
                my $inc = $2;
                $CONFIG{ 'verbose' } &&
                  print "\tFetching include: $inc\n";

                ##
                ## If this doesn't look like a fully qualified URL ..
                ##
                if ( $inc !~ /^https?:\/\//i )
                {

                    #
                    #  Try to resolve the path.
                    #
                    if ( $url =~ /^(.*)\/([^\/]+)$/ )
                    {
                        $inc = $1 . "/" . $inc;

                        $CONFIG{ 'verbose' } &&
                          print "\tTurned relative URL into: $inc\n";
                    }
                }

                #
                #  OK this is an icky thing ..
                #
                if ( $inc =~ /\$/ )
                {
                    $CONFIG{ 'verbose' } &&
                      print "\tTemplate expanding URL: $inc\n";

                    #
                    #  Looks like the policy has a template variable in
                    # it.  We might be wrong.
                    #
                    foreach my $key ( sort keys %CONFIG )
                    {
                        while ( $inc =~ /(.*)\$\Q$key\E(.*)/ )
                        {
                            $inc = $1 . $CONFIG{ $key } . $2;

                            $CONFIG{ 'verbose' } &&
                              print
                              "\tExpanded '\$$key' into '$CONFIG{$key}' giving: $inc\n";
                        }
                    }
                }

                #
                #  Now fetch it, resolved or relative.
                #
                my $policy = fetchRemotePolicy($inc);
                if ( defined($policy) )
                {
                    $ret .= $policy;
                }
                else
                {
                    $CONFIG{ 'verbose' } && print "Policy inclusion failed\n";
                }
            }
            else
            {
                $ret .= $line;
            }

            $ret .= "\n";

        }
        return ($ret);
    }

}


=begin doc

Fetch the contents of a remote URL.

=end doc

=cut

sub fetchPolicy
{
    my ($url) = (@_);

    $CONFIG{ 'verbose' } &&
      print "\tfetchURL( $url ) \n";

    my $ua = LWP::UserAgent->new();
    $ua->env_proxy();

    my $response = $ua->get($url);

    if ( $response->is_success() )
    {
        $CONFIG{ 'verbose' } &&
          print "\tOK\n";
        return ( $response->decoded_content() );
    }

    #
    #  Failed
    #
    $CONFIG{ 'verbose' } &&
      print "\tFailed to fetch: $url\n";
    return undef;
}




=begin doc

Write out specified policy content into a form which can be executed,
and return the name of the file to which it was written.

=end doc

=cut

sub writeoutPolicy
{
    my ($txt) = (@_);

    my ( undef, $name ) = File::Temp::tempfile();

    open my $handle, ">", $name or
      die "Failed to write to file : $!";

    print $handle <<EOF;
#!/usr/bin/perl
use strict;
use warnings;

use Slaughter;


# template variables.
EOF

    my $line = "my \%template = (";

    foreach my $key ( keys %CONFIG )
    {
        my $val = $CONFIG{ $key };

        if ( defined($val) )
        {
            print $handle "our \$$key = '$val';\n";
            $line .= "\n\t$key => '$val',";
        }
        else
        {
            print $handle "our \$$key = undef;\n";
            $line .= "\n\t$key => undef,";
        }

    }

    $line =~ s/, $//g;
    $line .= "\t);\n";
    print $handle "\n# template hash\n";
    print $handle $line . "\n";
    print $handle "#========\n\n";

    print $handle $txt;
    close($handle);

    if ( $^O ne "MSWin32" )
    {
        system( "chmod", "755", $name );
    }

    return ($name);

}


=begin doc

Find and return the name of the file to log this run to.

=end doc

=cut

sub getLogfile
{
    return undef if $CONFIG{ 'nolog' };

    #
    #  Ensure we have a log directory.
    #
    if ( !-d "/var/log/slaughter" )
    {
        mkpath( "/var/log/slaughter", { verbose => 0 } );
    }

    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
      localtime(time);

    $year += 1900;
    $mon  += 1;

    my $file = "/var/log/slaughter/$year-$mon-$mday.$$.log";

    $CONFIG{ 'verbose' } && print "Logfile: $file\n";

    return ($file);
}



=begin doc

Email the contents of the logfile to the named account.

=end doc

=cut

sub emailLogfile
{
    my ( $to, $file ) = (@_);

    #
    #  If the logfile doesn't exist we're in trouble.
    #
    return unless ( -e $file );

    #
    #  If the logfile is empty then there's no need to mail it.
    #
    return if ( -z $file );


    #
    #  Otherwise continue - with the path to sendmail.
    #
    my $sendmail = $CONFIG{ 'sendmail' } || "/usr/lib/sendmail -t";

    #
    #  The sender of the mail.
    #
    my $from = $CONFIG{ 'sender' } || "root";

    open( SENDMAIL, "|$sendmail -f $from" ) or
      return;
    print SENDMAIL <<EOF;
To: $to
From: $from
Subject: slaughter run on $CONFIG{'fqdn'}

EOF

    if ( open( my $handle, "<", $file ) )
    {
        while ( my $line = <$handle> )
        {
            print SENDMAIL $line;
        }
        close($handle);
    }

    close(SENDMAIL);
}
