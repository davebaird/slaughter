Overview
--------


 There are several phases to the execution of slaughter upon a client machine:

  - Determining information about the local system.
  - Reading the configuration file and parsing the command line options.
  - Fetching the remote policy/policies.
  - Wrapping the retrieved policy-code to make it valid Perl.
  - Executing the wrapped code.
  - Cleanup.

Because the code is wrapped in a little magic the primitives we've provided
are available.  These primitives are nothing more than exported subroutines
which become available due to this in the wrapped file:

    use Slaughter;

The Slaughter module is a stub which attempts to load the
platform-specific implementations of the subroutines from another
module, via the use of the perl $^O variable.

So, for example, on a GNU/Linux system "use Slaughter" actually becomes
"use Slaughter::API::linux".

If no specific file may be found then the fall-back module
Slaughter::API::generic is loaded - which print "Not implemented"
for each primitive.




System Information
------------------

When the slaughter client runs it gathers some meta-information about
the host it is executing upon.

All the meta-information is gleaned at runtime, by loading a specific
module.  The module must define the single method "MetaInformation" which
will populate a hash-reference.

You can find sample code in lib/Slaughter/Info/*.pm




Package Installation
--------------------

Package installation is also abstracted into a library of its own:

    Slaughter::Packages::linux

This is sufficient for the moment, as there is no non-Linux package
management support present in slaughter.  If that changes there is
obvious scope to add it into a new library - and that will be invoked
by the environment-specific lib/Slaughter/foo.pm helper.




Hacking Directions
------------------

Brief pointers on where you need to look to do different things:

   Hacking: Variables
   ------------------
    If you'd like to make a new variable available to running scripts you'll
   need to investigate the slaughter code if it is common to all environments
   (see the function "defaultOptions").  If the variable is specific to a
   particular operating-sytem it should be added to the relevant module beneath
   lib/Slaughter/Info/*.pm.

   Hacking: Functions
   ------------------
    If you'd like to make a new support function available implement it in
   lib/Slaughter/API/generic.pm to output an error - then in each of the available
   environment-specific libraries in that same directory.

   Hacking: Packages
   ------------------
    The interface to the system's packaging is currently only implemented
   for GNU/Linux, via lib/Slaughter/Packages/linux.pm.  I'd suggest if you
   add support for another platform you follow a similar naming scheme.

   Hacking: Transports
   -------------------
    If you'd like to add a new transport mechanism you should be able to do
   so copying one of the libraries in lib/Slaughter/Transport/.  Implement
   the required methods, such that the test cases pass and you're golden.
    Transports based on revision control software, are particularly trivial
   to implement using the base-class provided.  (Consult git.pm/hg.pm for examples.)



Submitting Patches
------------------

Patches are welcome.  Suggestions with no code are just as welcome.

However note that patches will be significantly more likely to be accepted
if they contain corresponding test-code, or test-cases.



Steve
--

